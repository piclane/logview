group 'me.piclane'
version '2.0.0'

apply plugin: 'java'
apply plugin: 'war'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
}

sourceSets {
    test {
        resources {
            srcDir 'src/test/java'
        }
    }
}

dependencies {
    def jerseyVersion = 2.25
    compileOnly "javax.websocket:javax.websocket-api:1.1"
    compileOnly "javax.servlet:javax.servlet-api:3.1.0"

    implementation "org.slf4j:slf4j-api:1.7.30"
    implementation "org.slf4j:jul-to-slf4j:1.7.30"
    implementation "ch.qos.logback:logback-core:1.2.3"
    implementation "ch.qos.logback:logback-classic:1.2.3"
    implementation "javax.servlet:jstl:1.2"
    implementation "com.google.code.gson:gson:2.8.6"
    implementation "com.github.albfernandez:juniversalchardet:2.2.0"
    implementation "jchardet:jchardet:1.1.0"
    implementation "org.glassfish.jersey.containers:jersey-container-servlet:${jerseyVersion}"
    implementation "org.glassfish.jersey.core:jersey-server:${jerseyVersion}"
    implementation "org.glassfish.jersey.core:jersey-server:${jerseyVersion}"
    implementation "org.glassfish.jersey.media:jersey-media-json-jackson:${jerseyVersion}"

    testImplementation "javax.websocket:javax.websocket-api:1.1"
    testImplementation "junit:junit:4.13"
    testImplementation "org.hamcrest:hamcrest-all:1.3"
    testImplementation "com.google.jimfs:jimfs:1.1"
    testImplementation "org.mockito:mockito-core:2.28.2"
    testImplementation "org.powermock:powermock-module-junit4:2.0.7"
    testImplementation "org.powermock:powermock-api-mockito2:2.0.7"
}

task sourceJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task buildNpm() {
    group = 'build'
    description = 'npm run build'
    doLast {
        "npm install"
            .execute(null, projectDir)
            .waitForProcessOutput(System.out, System.err)

        "npm run build"
            .execute(null, projectDir)
            .waitForProcessOutput(System.out, System.err)

        ant.move(todir: "${buildDir}/web/", overwrite: false) {
            fileset(dir: "${projectDir}/dist/")
        }
    }
}

task buildWeb() {
    doLast {
        ant.copy(todir: "${buildDir}/web/") {
            fileset(dir: "${projectDir}/web/")
        }
    }
}

war {
    def branchName = readBranch()
    switch (branchName) {
        case { isIdea() }:
            archiveName = "${project.name}.war"
            break
        case 'master':
        case 'develop':
        case ~/^tags\/.+$/:
        case { project.version ==~ /^.*_.+$/ }:
            archiveName = "${project.name}_${project.version}.war"
            break
        default:
            branchName = branchName.tr('\\/:*?"<>|', '＼／：＊？”＜＞｜')
            archiveName = "${project.name}_${project.version}_${branchName}.war"
            break
    }

    doFirst {
        exclude '**/WEB-INF/web.xml'
        webXml = file("${buildDir}/web/WEB-INF/web.xml")
        webAppDirName = "${buildDir}/web/"
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    dependsOn 'buildNpm'
    dependsOn 'buildWeb'
}

/**
 * ブランチ名を取得する
 *
 * @return ブランチ名
 */
static def readBranch() {
    return "git name-rev --name-only HEAD"
            .execute().text
            .trim()
            .replaceAll(/remotes\/origin\//, "")
            .replaceAll(/\^0$/, "")
}

/**
 * IntelliJ からの実行かどうかを取得します
 *
 * @return IntelliJ からの実行の場合 true そうでない場合 false
 */
static def isIdea() {
    return System.getProperty("idea.active", "false") == "true"
}